/***哈希***
#include <iostream>
#include <ext/hash_map>
#include <string>

using namespace __gnu_cxx;
using namespace std;
int main(){
        hash_map<int, string> mymap;
        mymap[9527]="唐伯虎点秋香";
        mymap[1000000]="百万富翁的生活";
//        mymap[10000]="白领的工资底线";
        if(mymap.find(10000) == mymap.end()){
            cout<< "hello1"<<endl;
        }
        else{
            cout<<  mymap[10000]<<endl;
        }
}

//哈希的遍历
for(auto i=mymap.begin();i!=frequent.end();i++){
    cout<<(*i).first<<"   "<<(*i).second<<endl;
}

//删除
hm.erase(9527);

//搜索
j=mymap.find("pear");
i=mymap.find("apple");
cout<<"水果："<<(*i).first<<"  "<<"价钱："<<(*i).second<<endl;
if(j!=hm.end())
{
cout<<"hash_map容器的个数"<<hm.size()<<endl;
}
else
{
cout<<"哈希表的表长："<<hm.bucket_count()<<endl;
}





***/


/***哈希2***
#include<unordered_set>

unordered_set<string> map;
map.insert("aaaaa");
map.count();
map.erase();
map.find()==map.end;

***/



/***01背包问题***

 * 给定 n 件物品，物品的重量为 w[i]，
 * 物品的价值为 c[i]。
 * 现挑选物品放入背包中，
 * 假定背包能承受的最大重量为 V，
 * 问应该如何选择装入背包中的物品，
 * 使得装入背包中物品的总价值最大？


#include<iostream>
#include<vector>
using namespace std;

int maxVaule(vector<int> vaule, vector<int> weight,int Weight)
{
    //vaule和weigh数组容量一致，表示总共有多少件物体
    int n = vaule.size();
    //保证索引从零开始，且初始化为0
    int dp[n+1][Weight+1];
    for(int i = 0;i<Weight+1;i++)
    for(int j = 0;j<n+1;j++)
        dp[j][i] = 0;
    for(int item=1;item<n+1;item++)
        for(int bag_weight=1;bag_weight<Weight+1;bag_weight++)
        {
            //vaule,weight的索引需要减一
            int withThis = bag_weight>=weight[item-1]?vaule[item-1] + dp[item-1][bag_weight-weight[item-1]]:0;
            int withoutThis = dp[item-1][bag_weight];
            dp[item][bag_weight] = max(withThis,withoutThis);
        }
    return dp[n][Weight];

}

int main()
{
    vector<int> vaule;
    vaule.push_back(3000);
    vaule.push_back(2000);
    vaule.push_back(1500);
    vector<int> weight;
    weight.push_back(4);
    weight.push_back(3);
    weight.push_back(1);

    x = weight.back();
    weight.pop_back();
    int val = maxVaule(vaule,weight,4);
    cout<<val<<endl;

    return 0;
}

***/



/***先序(中序)非递归遍历二叉树***

typedef struct TreeNode{
    int data;
    struct TreeNode *lChild;
    struct TreeNode *rChild;
}TreeNode;


void preOrder(TreeNode *T){
    TreeNode *stack[15];
    int top = -1;
    TreeNode *p = T;
    while(p!=NULL||top!=-1){
        if(p!=NULL){
            stack[++ top] = p;
            printf("%d\t",p->data); //入栈时，访问输出
            p = p->lChild;
        }else{
            p = stack[top --];
            p = p->rChild;
        }
    }
}
***/



/***中序递归遍历二叉树***
   void Inorder(TreeNode* root)
    {
        if(root==nullptr) return;

        Inorder(root->left);
        *
        * code...
        *
        Inorder(root->right);
    }
***/



/***层次遍历二叉树1***
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    queue<TreeNode *> nodeQueue;
    nodeQueue.push(root);

    TreeNode* p = nullptr;
    while(!nodeQueue.empty())
    {
        p = nodeQueue.front();
        cout<<p->val<<endl;
        nodeQueue.pop();
        if(p->left) nodeQueue.push(p->left);
        if(p->right) nodeQueue.push(p->right);
    }
    return result;
}
***/



/***层次遍历二叉树2（保留结点信息版）***
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if(root == nullptr) return result;
    vector<int> temp;
    vector<TreeNode *> nodeQueue(1200);
    int front = -1;
    int rear = -1;
    int last = 0;

    rear++;
    nodeQueue[rear] = root;
    TreeNode* p = nullptr;
    while(front<rear)
    {
        front++;
        p = nodeQueue[front];
        temp.push_back(p->val);
        if(p->left)
        {
            rear++;
            nodeQueue[rear] = p->left;
        }
        if(p->right)
        {
            rear++;
            nodeQueue[rear] = p->right;
        }
        if(front == last)
        {

            result.push_back(temp);
            temp.clear();
            last = rear;
        }
    }
    return result;
}
***/


/***层次遍历二叉树3（保留层次信息版）***
    Node* connect(Node* root) {
    if(root==nullptr)return root;
    queue<Node *> nodeQueue;
    nodeQueue.push(root);
    Node* last = root;

    Node* p = nullptr;
    Node* finPush = nullptr;

    while(!nodeQueue.empty())
    {
        p = nodeQueue.front();
        nodeQueue.pop();
        if(p->left) {
            finPush = p->left;
            nodeQueue.push(p->left);
        }
        if(p->right){
            finPush = p->right;
            nodeQueue.push(p->right);
        }
        if(last == p)
        {
            last = finPush;
        }
    }
    return root;
    }
***/


/***全排列****

auto mySwap = [](int &a,int &b){ int temp=a;a=b;b=temp; };
class Solution {
public:

    void myPermute(vector<vector<int>> &result,vector<int>& nums,int layer,int n){
        if(layer==n){
            result.push_back(nums);
            return;
        }
        for(int i = layer;i<n;i++){
            mySwap(nums[i],nums[layer]);
            myPermute(result,nums,layer+1,n);
            mySwap(nums[i],nums[layer]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        myPermute(result,nums,0,nums.size());
        return result;
    }
};

***/


/***c++常用语法***

//创建一个对象指针和创建一个对象
KthLargest* obj = new KthLargest(k, nums);
Pointer p = Pointer("point");

//for
for(auto &c : str)
{
    c = toupper(c);
}

 *****/



/***c++队列*******

#include <queue>

queue<int> q1;

q1.push(i);
q1.empty();
q1.size();
q1.back();
q1.front();
q1.pop();
 * **************/



/*****string操作******

// 字符串转换为数字

string number;
cout<<atoi((char *)number.c_str())<<endl;

//将整型转换为字符串
to_string(i);

//字符转换为字符串
char c = 'c';
string s(1, c);
cout << s == "c" ? true : false << endl;

//拼接字符串
string s1 = "alan";
string s2 = "xiho";

//1.
string s3 = s1 + s2;

string s4 = " wahaha";

s1.insert(2, "123");

//2.
s3.append(s4);

//获取子串
s.substr(start,length);



/****vector操作****
{
     //合并两个vector
     vec3.insert(vec3.end(),vec1.begin(),vec1.end());

     //二维数组
     vector<vector<int>>vec(m,vector<int>(n,0));    //m*n的二维vector，所有元素为0

     //一维数组
     vector<int> vec1{ 1, 2, 3, 4, 5, 6 };

     //尾插
     v1.push_back(10);
     v1.push_back(20);

     //尾删
     v1.pop_back();

     //插入 更换位置可以用v1.begin+n
     v1.insert(v1.begin(), 100);
     v1.insert(v1.begin(), 2, 1000);

     //删除指定位置
     v1.erase(v1.begin());
     v1.erase(v1.begin(), v1.end());

     //清空，并且释放内存
     v1.clear();

     //复制一个数组
     vector<int> mat;
     mat.assign(Vec.begin(), Vec.end());


    //自定义排序函数
    bool SortByM1( const Test &v1, const Test &v2)//注意：本函数的参数的类型一定要与vector中元素的类型一致
    {
        return v1.member1 < v2.member1;//升序排列
    }

    auto SortByM2 = [](freq &v1,freq &v2){ return v1.frequent > v2.frequent; };
    //排序
    std::sort(vecTest.begin(),vecTest.end(),SortByM1);

    //迭代器的数据是指针
    //迭代器
    for (vector<int>::iterator i = vec.begin(); i != vec.end(); ++i) {  //用迭代器遍历容器
    //begin()返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end()返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是i != v.end()。
        cout << *i << " ";  //*i 就是迭代器i指向的元素
        *i *= 2;  //每个元素变为原来的2倍
    }
    //反向迭代器
    for (vector<int>::reverse_iterator j = vec.rbegin(); j != vec.rend(); ++j)
        //rbegin()返回指向容器中最后一个元素的迭代器，rend()返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。
        cout << *j << " ";



 }
***/


/***快速排序***
void quicksort(vector<int>& nums,int start,int end){
    if(start>=end) return;
    int i = start;
    int j = end;
    int temp = nums[start];

    while(i<j)
    {
        while(i<j&&nums[j]>=temp)j--;
        if(i<j)
        {
            nums[i] = nums[j];
            i++;
        }
        while(i<j&&nums[i]<=temp)i++;
        if(i<j)
        {
            nums[j] = nums[i];
            j--;
        }

    }
    nums[i] = temp;
    quicksort(nums,start,i-1);
    quicksort(nums,i+1,end);
}
***/



/***字符vector和string相互转换

    vector转string
    vector<uint8_t> Vec(6, 7);
    string Str;
    Str.assign(Vec.begin(), Vec.end());

    string转vector
    vector<unsigned char> Vec1;
    string Str{"123456"};
    Vec1.assign(Str.begin(), Str.end());
***/



/***求对数且向上取整***
double log2Up(int n)
{
    return ceil(log(n+1)/log(2));
}
***/



/****lambda表达式****
 * 这样add就可以当做函数用
#include <iostream>
using namespace std;
auto mySwap = [](int &a,int &b){ int temp=a;a=b;b=temp; };
int main()
{
    int a = 5;
    int b = 6;
    mySwap(a,b);
    cout<<a<<b<<endl;
    return 0;
}

****/



/****KMP算法生成next数组****


void getNext(string substr,vector<int >& next)
{
    int i=0;
    int j = -1;
    next[i] = j;
    while(i<substr.length())
    {
        if(j==-1 || substr[i] == substr[j])
        {
            j++;
            i++;
            next[i] = j;
        }else
        {
            j = next[j];
        }
    }
}

****/
